from queue import Queue
import io
from .utils import levels
from typing import Optional, Tuple, Dict, Any, Union, NewType

Primitive = NewType('Primitive', Union[dict, list, tuple, str, float, int])

class ProcessMonitor:
    def __init__(self, interval: float=1, run_as_thread: bool=False, listen_to_output: bool=False) -> None:
        self.stop = None  # type: Queue
        self.output = None  # type: Queue
        self.active = ...  # type: bool
        self.interval = ...  # type: float
        self.run_as_thread = ...  # type: bool
        self.listen_to_output = ...  # type: bool
        ...
    @staticmethod
    def __del__(self) -> None: ...
    def set_up(self, parent, stop: Queue, output: Queue) -> None: ...
    def _set_up(self, parent) -> None: ...
    def tear_down(self, returncode: int=0) -> None: ...
    def _tear_down(self, returncode: int) -> None: ...
    def get_settings(self) -> Dict[str, Any]: ...
    def verify(self) -> Optional[Tuple[int, str]]: ...
    def log(self, message: Primitive, identifier: int) -> None: ...
    def info(self, message: Primitive) -> None: ...
    def warn(self, message: Primitive) -> None: ...
    def error(self, message: Primitive) -> None: ...
    def status(self, message: Primitive) -> None: ...
    def get_log(self, msg: Primitive, identifier: int) -> None: ...


class Logfile(ProcessMonitor):
    def __init__(self, fn: str=None, force: bool=False) -> None:
        self.fn = None  # type: str
        self.fnrunning = None  # type: str
        self.fnsuccess = None  # type: str
        self.fnfailure = None  # type: str
        self.force = ...  # type: bool
        self.file = ...  # type: io.FileIO
        ...
    def open(self) -> None: ...
    def get_settings(self) -> Dict[str, Any]: ...
    def verify(self) -> Optional[Tuple[int, str]]: ...
    def close(self, returncode: int=None) -> None: ...
    def _set_up(self, parent) -> None: ...
    def _tear_down(self, returncode: int=0) -> None: ...
    def is_success(self) -> bool: ...
    def is_running(self) -> bool: ...
    def is_failed(self) -> bool: ...
    def get_log(self, msg: str, identifier: int) -> None: ...


class Print(ProcessMonitor):
    def __init__(self, log_lvl:int=levels.INFO, include_stdout:bool=True) -> None:
        self.log_lvl = ...  # type: int
        self.include_stdout = ...  # type: bool
        self.stdout = ... # type: io.IOBase
        ...
    def get_log(self, msg: str, identifier: int) -> None: ...


class JsonFile(ProcessMonitor):
    def __init__(self, fn:str, log_lvl:int=levels.SETTINGS, include_stdout:bool=False):
        self.fn = ...  # type: str
        self.log_lvl = ...  # type: int
        self.include_stdout = ...  # type: bool
        self.file = ...  # type: io.FileIO
        self.first = ...  # type: bool
        ...
    def _set_up(self, parent) -> None: ...
    def _tear_down(self, returncode: int) -> None: ...
    def write(self, data, identifier: int) -> None: ...
    def get_log(self, msg: str, identifier: int) -> None: ...


class MemoryLimit(ProcessMonitor):
    def __init__(self, maxmem: float=None, minavailable: float=None) -> None:
        self.maxmem = ...  # type: float
        self.minavailable = ...  # type: float
        ...
    def _set_up(self, parent) -> None: ...
    def get_settings(self) -> Dict[str, Any]: ...
    def verify(self) -> Optional[Tuple[int, str]]: ...


class TimeLimit(ProcessMonitor):
    def __init__(self, walltime: float) -> None:
        self.maxtime = ...  # type: float
        self.end_time = ...  # type: float
        ...
    def _set_up(self, parent) -> None: ...
    def get_settings(self) -> Dict[str, Any]: ...
    def verify(self) -> Optional[Tuple[int, str]]: ...


class FileSizeLimit(ProcessMonitor):
    def __init__(self, filename: str, maxsize: int=None) -> None:
        self.maxsize = ...  # type: int
        self.filename = ...  # type: str
        ...
    def get_settings(self) -> Dict[str, Any]: ...
    def verify(self) -> Optional[Tuple[int, str]]: ...


class DiskSpaceLimit(ProcessMonitor):
    def __init__(self, minavailable: float=None) -> None:
        self.minavailable = ...  # type: float
        ...
    def get_settings(self) -> Dict[str, Any]: ...
    def verify(self) -> Optional[Tuple[int, str]]: ...
